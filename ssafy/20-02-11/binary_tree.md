# Binary Tree
### 표현
1. 1차원 배열로 이진트리 표현
    - 왼쪽 자식은 부모 인덱스x2, 오른쪽 자식은 부모 인덱스x2 + 1 위치
    - 레벨 n의 시작 노드 인덱스는 2^n
    - 단, skewed binary tree일 경우 메모리 낭비가 심함
        - 트리가 항상 complete binary tree일 경우에는 배열로 구현
            - 2차원 배열: 1차 인덱스는 노드 번호, 인덱스 0에는 왼쪽 자식, 1에는 오른쪽 자식, 2에는 부모
        - 그렇지 않으면 링크드 리스트 사용
    - 트리 중간에 새로운 노드 삽입 및 삭제할 시 배열 크기의 변경이 어려움
2. 링크드 리스트로 구현
    - 공간낭비 없으나 구현이 불편
    - 보통 노드 하나에 왼쪽 자식, 오른쪽 자식, 부모를 넣음
        - 따라서 간선의 수는 모든 노드의 자식 수와 같음
        - 부모 정보를 넣으면 조상 노드에 대해 쉽게 구할 수 있음
            - ex) 두 노드의 공통 조상 중 가장 가까운 공통 조상 구하기

### Expression Binary Tree
- 수식 이진 트리
- 연산자는 루트 노드이거나 가지 노드
- 피연산자는 모두 잎노드
- post-order로 돌리면 수식의 연산 가능

### Bineary Search Tree
- 이진 탐색을 위한 이진 트리
- In-order 순회 시 sorting된 결과를 볼 수 있음
- 삽입 시
    - 해당 값을 탐색 한 후의 자리에 삽입
- 삭제 시
    1. 자식 없을 때: 그냥 삭제
    2. 자식 1개일 때: 자식을 자신 위치에 두고 자기 삭제
    3. 자식 2개일 때: 왼쪽 자식 트리의 가장 큰 값 또는 오른쪽 자식 트리의 가장 작은 값을 자신 위치에 둠
        - 왼쪽 자식 트리의 가장 큰 값: 왼쪽 트리의 오른쪽 자식만을 쭉 따라가다 더 이상 없는 노드
        - 오른쪽 자식 트리의 가장 큰 값: 오른쪽 트리의 왼쪽 자식만을 쭉 따라가다 더 이상 없는 노드
- 평균 탐색 시간은 O(logN): 트리의 깊이만큼 걸림
- 최악 탐색 시간은 O(n): skewed tree일 때
    - AVL tree 사용하여 해결 가능

### Heap
- complete binary tree에서 키 값이 가장 큰 노드나 가장 작은 노드를 찾기 위한 자료구조
    - 최대 힙: 루트가 키 값이 가장 큼, 부모 키 값 > 자식 키 값
    - 최소 힙: 루트가 키 값이 가장 작음, 부모 키 값 < 자식 키 값
- Priority Queue 구현에 사용
- 반드시 완전 이진 트리여야 함
    - 마지막 노드 까지 비어있는 노드가 없어야 함
    - 보통 1차 배열을 사용하여 구현하므로 인덱스 순서에 따라 삽입 == 완전 이진 트리
- 삽입 시
    1. 완전 이진 트리를 만들어 가면서 부모의 키 값과 비교하여 맞지 않으면 부모와 위치 바꿈
        - 부모-자식 비교 시에는 index*2, index*2 + 1로 가능
    2. 루트까지(부모와 키 값이 올바를 때까지) 1번을 반복
- 삭제 시
    1. 루트 노드를 pop하고 힙의 맨 끝 노드(인덱스가 가장 큰)를 루트에 놓음
    2. 바뀐 루트 노드에서부터 자식 노드 중 크거나 작은 노드와 위치를 바꿈, 이를 반복
- 이를 이용하여 heap sort 가능
    - O(logN)

### 허프만 알고리즘
- 암호화 압축 알고리즘
- 빈도수가 가장 많은 문자에 짧은 비트열을 대입시킴
    - ex) A가 400개, B가 100개일 때 A에는 0, B에는 10을 대입시켜 전체 비트 수를 줄임
- 디코딩 테이블이 없으면 원래 정보를 알 수 없으므로 암호화 가능
